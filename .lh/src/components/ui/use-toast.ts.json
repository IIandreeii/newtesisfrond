{
    "sourceFile": "src/components/ui/use-toast.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1745195628509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745462923464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,193 @@\n+\"use client\"\n+\n+// Inspired by react-hot-toast library\n+import * as React from \"react\"\n+\n+import type {\n+  ToastActionElement,\n+  ToastProps,\n+} from \"@/components/ui/toast\"\n+\n+const TOAST_LIMIT = 1\n+const TOAST_REMOVE_DELAY = 1000000\n+\n+type ToasterToast = ToastProps & {\n+  id: string\n+  title?: React.ReactNode\n+  description?: React.ReactNode\n+  action?: ToastActionElement\n+}\n+\n+// Definir directamente como un tipo en lugar de un objeto\n+type ActionType = {\n+  ADD_TOAST: \"ADD_TOAST\",\n+  UPDATE_TOAST: \"UPDATE_TOAST\",\n+  DISMISS_TOAST: \"DISMISS_TOAST\",\n+  REMOVE_TOAST: \"REMOVE_TOAST\",\n+}\n+\n+type Action =\n+  | {\n+      type: \"ADD_TOAST\"\n+      toast: ToasterToast\n+    }\n+  | {\n+      type: \"UPDATE_TOAST\"\n+      toast: Partial<ToasterToast>\n+    }\n+  | {\n+      type: \"DISMISS_TOAST\"\n+      toastId?: ToasterToast[\"id\"]\n+    }\n+  | {\n+      type: \"REMOVE_TOAST\"\n+      toastId?: ToasterToast[\"id\"]\n+    }\n+\n+let count = 0\n+\n+function genId() {\n+  count = (count + 1) % Number.MAX_SAFE_INTEGER\n+  return count.toString()\n+}\n+\n+interface State {\n+  toasts: ToasterToast[]\n+}\n+\n+const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n+\n+const addToRemoveQueue = (toastId: string) => {\n+  if (toastTimeouts.has(toastId)) {\n+    return\n+  }\n+\n+  const timeout = setTimeout(() => {\n+    toastTimeouts.delete(toastId)\n+    dispatch({\n+      type: \"REMOVE_TOAST\",\n+      toastId: toastId,\n+    })\n+  }, TOAST_REMOVE_DELAY)\n+\n+  toastTimeouts.set(toastId, timeout)\n+}\n+\n+export const reducer = (state: State, action: Action): State => {\n+  switch (action.type) {\n+    case \"ADD_TOAST\":\n+      return {\n+        ...state,\n+        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n+      }\n+\n+    case \"UPDATE_TOAST\":\n+      return {\n+        ...state,\n+        toasts: state.toasts.map((t) =>\n+          t.id === action.toast.id ? { ...t, ...action.toast } : t\n+        ),\n+      }\n+\n+    case \"DISMISS_TOAST\": {\n+      const { toastId } = action\n+\n+      // ! Side effects ! - This could be extracted into a dismissToast() action,\n+      // but I'll keep it here for simplicity\n+      if (toastId) {\n+        addToRemoveQueue(toastId)\n+      } else {\n+        state.toasts.forEach((toast) => {\n+          addToRemoveQueue(toast.id)\n+        })\n+      }\n+\n+      return {\n+        ...state,\n+        toasts: state.toasts.map((t) =>\n+          t.id === toastId || toastId === undefined\n+            ? {\n+                ...t,\n+                open: false,\n+              }\n+            : t\n+        ),\n+      }\n+    }\n+    case \"REMOVE_TOAST\":\n+      if (action.toastId === undefined) {\n+        return {\n+          ...state,\n+          toasts: [],\n+        }\n+      }\n+      return {\n+        ...state,\n+        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n+      }\n+  }\n+}\n+\n+const listeners: Array<(state: State) => void> = []\n+\n+let memoryState: State = { toasts: [] }\n+\n+function dispatch(action: Action) {\n+  memoryState = reducer(memoryState, action)\n+  listeners.forEach((listener) => {\n+    listener(memoryState)\n+  })\n+}\n+\n+type Toast = Omit<ToasterToast, \"id\">\n+\n+function toast({ ...props }: Toast) {\n+  const id = genId()\n+\n+  const update = (props: ToasterToast) =>\n+    dispatch({\n+      type: \"UPDATE_TOAST\",\n+      toast: { ...props, id },\n+    })\n+  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n+\n+  dispatch({\n+    type: \"ADD_TOAST\",\n+    toast: {\n+      ...props,\n+      id,\n+      open: true,\n+      onOpenChange: (open: boolean) => {  // Cambiado de 'any' a 'boolean'\n+        if (!open) dismiss()\n+      },\n+    },\n+  })\n+\n+  return {\n+    id: id,\n+    dismiss,\n+    update,\n+  }\n+}\n+\n+function useToast() {\n+  const [state, setState] = React.useState<State>(memoryState)\n+\n+  React.useEffect(() => {\n+    listeners.push(setState)\n+    return () => {\n+      const index = listeners.indexOf(setState)\n+      if (index > -1) {\n+        listeners.splice(index, 1)\n+      }\n+    }\n+  }, [state])\n+\n+  return {\n+    ...state,\n+    toast,\n+    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n+  }\n+}\n+\n+export { useToast, toast }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745462962196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,15 +18,10 @@\n   action?: ToastActionElement\n }\n \n // Definir directamente como un tipo en lugar de un objeto\n-type ActionType = {\n-  ADD_TOAST: \"ADD_TOAST\",\n-  UPDATE_TOAST: \"UPDATE_TOAST\",\n-  DISMISS_TOAST: \"DISMISS_TOAST\",\n-  REMOVE_TOAST: \"REMOVE_TOAST\",\n-}\n \n+\n type Action =\n   | {\n       type: \"ADD_TOAST\"\n       toast: ToasterToast\n@@ -189,199 +184,5 @@\n     dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n   }\n }\n \n-export { useToast, toast }\n-\"use client\"\n-\n-// Inspired by react-hot-toast library\n-import * as React from \"react\"\n-\n-import type {\n-  ToastActionElement,\n-  ToastProps,\n-} from \"@/components/ui/toast\"\n-\n-const TOAST_LIMIT = 1\n-const TOAST_REMOVE_DELAY = 1000000\n-\n-type ToasterToast = ToastProps & {\n-  id: string\n-  title?: React.ReactNode\n-  description?: React.ReactNode\n-  action?: ToastActionElement\n-}\n-\n-const actionTypes = {\n-  ADD_TOAST: \"ADD_TOAST\",\n-  UPDATE_TOAST: \"UPDATE_TOAST\",\n-  DISMISS_TOAST: \"DISMISS_TOAST\",\n-  REMOVE_TOAST: \"REMOVE_TOAST\",\n-} as const\n-\n-let count = 0\n-\n-function genId() {\n-  count = (count + 1) % Number.MAX_SAFE_INTEGER\n-  return count.toString()\n-}\n-\n-type ActionType = typeof actionTypes\n-\n-type Action =\n-  | {\n-      type: ActionType[\"ADD_TOAST\"]\n-      toast: ToasterToast\n-    }\n-  | {\n-      type: ActionType[\"UPDATE_TOAST\"]\n-      toast: Partial<ToasterToast>\n-    }\n-  | {\n-      type: ActionType[\"DISMISS_TOAST\"]\n-      toastId?: ToasterToast[\"id\"]\n-    }\n-  | {\n-      type: ActionType[\"REMOVE_TOAST\"]\n-      toastId?: ToasterToast[\"id\"]\n-    }\n-\n-interface State {\n-  toasts: ToasterToast[]\n-}\n-\n-const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n-\n-const addToRemoveQueue = (toastId: string) => {\n-  if (toastTimeouts.has(toastId)) {\n-    return\n-  }\n-\n-  const timeout = setTimeout(() => {\n-    toastTimeouts.delete(toastId)\n-    dispatch({\n-      type: \"REMOVE_TOAST\",\n-      toastId: toastId,\n-    })\n-  }, TOAST_REMOVE_DELAY)\n-\n-  toastTimeouts.set(toastId, timeout)\n-}\n-\n-export const reducer = (state: State, action: Action): State => {\n-  switch (action.type) {\n-    case \"ADD_TOAST\":\n-      return {\n-        ...state,\n-        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n-      }\n-\n-    case \"UPDATE_TOAST\":\n-      return {\n-        ...state,\n-        toasts: state.toasts.map((t) =>\n-          t.id === action.toast.id ? { ...t, ...action.toast } : t\n-        ),\n-      }\n-\n-    case \"DISMISS_TOAST\": {\n-      const { toastId } = action\n-\n-      // ! Side effects ! - This could be extracted into a dismissToast() action,\n-      // but I'll keep it here for simplicity\n-      if (toastId) {\n-        addToRemoveQueue(toastId)\n-      } else {\n-        state.toasts.forEach((toast) => {\n-          addToRemoveQueue(toast.id)\n-        })\n-      }\n-\n-      return {\n-        ...state,\n-        toasts: state.toasts.map((t) =>\n-          t.id === toastId || toastId === undefined\n-            ? {\n-                ...t,\n-                open: false,\n-              }\n-            : t\n-        ),\n-      }\n-    }\n-    case \"REMOVE_TOAST\":\n-      if (action.toastId === undefined) {\n-        return {\n-          ...state,\n-          toasts: [],\n-        }\n-      }\n-      return {\n-        ...state,\n-        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n-      }\n-  }\n-}\n-\n-const listeners: Array<(state: State) => void> = []\n-\n-let memoryState: State = { toasts: [] }\n-\n-function dispatch(action: Action) {\n-  memoryState = reducer(memoryState, action)\n-  listeners.forEach((listener) => {\n-    listener(memoryState)\n-  })\n-}\n-\n-type Toast = Omit<ToasterToast, \"id\">\n-\n-function toast({ ...props }: Toast) {\n-  const id = genId()\n-\n-  const update = (props: ToasterToast) =>\n-    dispatch({\n-      type: \"UPDATE_TOAST\",\n-      toast: { ...props, id },\n-    })\n-  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n-\n-  dispatch({\n-    type: \"ADD_TOAST\",\n-    toast: {\n-      ...props,\n-      id,\n-      open: true,\n-      onOpenChange: (open: any) => {\n-        if (!open) dismiss()\n-      },\n-    },\n-  })\n-\n-  return {\n-    id: id,\n-    dismiss,\n-    update,\n-  }\n-}\n-\n-function useToast() {\n-  const [state, setState] = React.useState<State>(memoryState)\n-\n-  React.useEffect(() => {\n-    listeners.push(setState)\n-    return () => {\n-      const index = listeners.indexOf(setState)\n-      if (index > -1) {\n-        listeners.splice(index, 1)\n-      }\n-    }\n-  }, [state])\n-\n-  return {\n-    ...state,\n-    toast,\n-    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n-  }\n-}\n-\n export { useToast, toast }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745462969343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,11 +17,11 @@\n   description?: React.ReactNode\n   action?: ToastActionElement\n }\n \n-// Definir directamente como un tipo en lugar de un objeto\n \n \n+\n type Action =\n   | {\n       type: \"ADD_TOAST\"\n       toast: ToasterToast\n"
                }
            ],
            "date": 1745195628509,
            "name": "Commit-0",
            "content": "\"use client\"\n\n// Inspired by react-hot-toast library\nimport * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open: any) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n"
        }
    ]
}