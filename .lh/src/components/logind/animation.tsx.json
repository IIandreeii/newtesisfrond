{
    "sourceFile": "src/components/logind/animation.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1745196762391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745196771734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,96 +2,96 @@\n \r\n import { useEffect, useRef } from \"react\"\r\n \r\n export default function AnimatedBackground() {\r\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+    const canvasRef = useRef<HTMLCanvasElement>(null)\r\n \r\n-  useEffect(() => {\r\n-    const canvas = canvasRef.current\r\n-    if (!canvas) return\r\n+    useEffect(() => {\r\n+        const canvas = canvasRef.current\r\n+        if (!canvas) return\r\n \r\n-    const ctx = canvas.getContext(\"2d\")\r\n-    if (!ctx) return\r\n+        const ctx = canvas.getContext(\"2d\")\r\n+        if (!ctx) return\r\n \r\n-    // Configurar el canvas para que ocupe toda la pantalla\r\n-    const resizeCanvas = () => {\r\n-      canvas.width = window.innerWidth\r\n-      canvas.height = window.innerHeight\r\n-    }\r\n+       \r\n+        const resizeCanvas = () => {\r\n+            canvas.width = window.innerWidth\r\n+            canvas.height = window.innerHeight\r\n+        }\r\n \r\n-    resizeCanvas()\r\n-    window.addEventListener(\"resize\", resizeCanvas)\r\n+        resizeCanvas()\r\n+        window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-    // Colores minimalistas\r\n-    const colors = {\r\n-      primary: \"#e0f2fe\", // Azul claro\r\n-      secondary: \"#dcfce7\", // Verde menta\r\n-      accent: \"#fce7f3\", // Rosa pálido\r\n-      background: \"#f8fafc\", // Blanco grisáceo\r\n-    }\r\n+        // Colores minimalistas\r\n+        const colors = {\r\n+            primary: \"#e0f2fe\", // Azul claro\r\n+            secondary: \"#dcfce7\", // Verde menta\r\n+            accent: \"#fce7f3\", // Rosa pálido\r\n+            background: \"#f8fafc\", // Blanco grisáceo\r\n+        }\r\n \r\n-    // Crear círculos con diferentes colores y tamaños\r\n-    const circles: Circle[] = []\r\n-    const circleCount = 15\r\n+        // Crear círculos con diferentes colores y tamaños\r\n+        const circles: Circle[] = []\r\n+        const circleCount = 15\r\n \r\n-    for (let i = 0; i < circleCount; i++) {\r\n-      const radius = Math.random() * 150 + 50\r\n-      circles.push({\r\n-        x: Math.random() * canvas.width,\r\n-        y: Math.random() * canvas.height,\r\n-        radius,\r\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n-        speedX: (Math.random() - 0.5) * 0.3,\r\n-        speedY: (Math.random() - 0.5) * 0.3,\r\n-        opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n-      })\r\n-    }\r\n+        for (let i = 0; i < circleCount; i++) {\r\n+            const radius = Math.random() * 150 + 50\r\n+            circles.push({\r\n+                x: Math.random() * canvas.width,\r\n+                y: Math.random() * canvas.height,\r\n+                radius,\r\n+                color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n+                speedX: (Math.random() - 0.5) * 0.3,\r\n+                speedY: (Math.random() - 0.5) * 0.3,\r\n+                opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n+            })\r\n+        }\r\n \r\n-    // Función de animación\r\n-    const animate = () => {\r\n-      ctx.fillStyle = colors.background\r\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+        // Función de animación\r\n+        const animate = () => {\r\n+            ctx.fillStyle = colors.background\r\n+            ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n \r\n-      // Dibujar y mover círculos\r\n-      circles.forEach((circle) => {\r\n-        ctx.beginPath()\r\n-        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n-        ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n-          .toString(16)\r\n-          .padStart(2, \"0\")}`\r\n-        ctx.fill()\r\n+            // Dibujar y mover círculos\r\n+            circles.forEach((circle) => {\r\n+                ctx.beginPath()\r\n+                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n+                ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n+                    .toString(16)\r\n+                    .padStart(2, \"0\")}`\r\n+                ctx.fill()\r\n \r\n-        // Mover círculo\r\n-        circle.x += circle.speedX\r\n-        circle.y += circle.speedY\r\n+                // Mover círculo\r\n+                circle.x += circle.speedX\r\n+                circle.y += circle.speedY\r\n \r\n-        // Rebotar en los bordes\r\n-        if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n-          circle.speedX = -circle.speedX\r\n+                // Rebotar en los bordes\r\n+                if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n+                    circle.speedX = -circle.speedX\r\n+                }\r\n+                if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n+                    circle.speedY = -circle.speedY\r\n+                }\r\n+            })\r\n+\r\n+            requestAnimationFrame(animate)\r\n         }\r\n-        if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n-          circle.speedY = -circle.speedY\r\n-        }\r\n-      })\r\n \r\n-      requestAnimationFrame(animate)\r\n-    }\r\n+        animate()\r\n \r\n-    animate()\r\n+        return () => {\r\n+            window.removeEventListener(\"resize\", resizeCanvas)\r\n+        }\r\n+    }, [])\r\n \r\n-    return () => {\r\n-      window.removeEventListener(\"resize\", resizeCanvas)\r\n-    }\r\n-  }, [])\r\n-\r\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n+    return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n }\r\n \r\n interface Circle {\r\n-  x: number\r\n-  y: number\r\n-  radius: number\r\n-  color: string\r\n-  speedX: number\r\n-  speedY: number\r\n-  opacity: number\r\n+    x: number\r\n+    y: number\r\n+    radius: number\r\n+    color: string\r\n+    speedX: number\r\n+    speedY: number\r\n+    opacity: number\r\n }\r\n"
                },
                {
                    "date": 1745196780455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,17 +20,17 @@\n \r\n         resizeCanvas()\r\n         window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-        // Colores minimalistas\r\n+        \r\n         const colors = {\r\n             primary: \"#e0f2fe\", // Azul claro\r\n             secondary: \"#dcfce7\", // Verde menta\r\n             accent: \"#fce7f3\", // Rosa pálido\r\n             background: \"#f8fafc\", // Blanco grisáceo\r\n         }\r\n \r\n-        // Crear círculos con diferentes colores y tamaños\r\n+        \r\n         const circles: Circle[] = []\r\n         const circleCount = 15\r\n \r\n         for (let i = 0; i < circleCount; i++) {\r\n"
                },
                {
                    "date": 1745197381680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,97 +1,253 @@\n \"use client\"\r\n \r\n-import { useEffect, useRef } from \"react\"\r\n+import { useEffect, useRef, useState } from \"react\"\r\n \r\n export default function AnimatedBackground() {\r\n-    const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\r\n \r\n-    useEffect(() => {\r\n-        const canvas = canvasRef.current\r\n-        if (!canvas) return\r\n+  useEffect(() => {\r\n+    const canvas = canvasRef.current\r\n+    if (!canvas) return\r\n \r\n-        const ctx = canvas.getContext(\"2d\")\r\n-        if (!ctx) return\r\n+    const ctx = canvas.getContext(\"2d\")\r\n+    if (!ctx) return\r\n \r\n-       \r\n-        const resizeCanvas = () => {\r\n-            canvas.width = window.innerWidth\r\n-            canvas.height = window.innerHeight\r\n-        }\r\n+    // Configurar el canvas para que ocupe toda la pantalla\r\n+    const resizeCanvas = () => {\r\n+      canvas.width = window.innerWidth\r\n+      canvas.height = window.innerHeight\r\n+    }\r\n \r\n-        resizeCanvas()\r\n-        window.addEventListener(\"resize\", resizeCanvas)\r\n+    resizeCanvas()\r\n+    window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-        \r\n-        const colors = {\r\n-            primary: \"#e0f2fe\", // Azul claro\r\n-            secondary: \"#dcfce7\", // Verde menta\r\n-            accent: \"#fce7f3\", // Rosa pálido\r\n-            background: \"#f8fafc\", // Blanco grisáceo\r\n-        }\r\n+    // Seguimiento del cursor\r\n+    const handleMouseMove = (e: MouseEvent) => {\r\n+      setMousePosition({ x: e.clientX, y: e.clientY })\r\n+    }\r\n+    window.addEventListener(\"mousemove\", handleMouseMove)\r\n \r\n-        \r\n-        const circles: Circle[] = []\r\n-        const circleCount = 15\r\n+    // Colores minimalistas pero más vibrantes\r\n+    const colors = {\r\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\r\n+      secondary: \"#4ade80\", // Verde menta más vibrante\r\n+      accent: \"#f472b6\", // Rosa más vibrante\r\n+      background: \"#f8fafc\", // Blanco grisáceo\r\n+    }\r\n \r\n-        for (let i = 0; i < circleCount; i++) {\r\n-            const radius = Math.random() * 150 + 50\r\n-            circles.push({\r\n-                x: Math.random() * canvas.width,\r\n-                y: Math.random() * canvas.height,\r\n-                radius,\r\n-                color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n-                speedX: (Math.random() - 0.5) * 0.3,\r\n-                speedY: (Math.random() - 0.5) * 0.3,\r\n-                opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n-            })\r\n-        }\r\n+    // Crear diferentes tipos de formas\r\n+    const shapes: Shape[] = []\r\n+    const shapeCount = 25 // Más formas para mayor dinamismo\r\n \r\n-        // Función de animación\r\n-        const animate = () => {\r\n-            ctx.fillStyle = colors.background\r\n-            ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+    // Crear círculos\r\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\r\n+      const radius = Math.random() * 120 + 40\r\n+      shapes.push({\r\n+        type: \"circle\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: radius,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: radius,\r\n+        rotation: 0,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\r\n+      })\r\n+    }\r\n \r\n-            // Dibujar y mover círculos\r\n-            circles.forEach((circle) => {\r\n-                ctx.beginPath()\r\n-                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n-                ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n-                    .toString(16)\r\n-                    .padStart(2, \"0\")}`\r\n-                ctx.fill()\r\n+    // Crear cuadrados\r\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n+      const size = Math.random() * 100 + 30\r\n+      shapes.push({\r\n+        type: \"square\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: size,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n+        speedX: (Math.random() - 0.5) * 1.0,\r\n+        speedY: (Math.random() - 0.5) * 1.0,\r\n+        opacity: Math.random() * 0.3 + 0.15,\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: size,\r\n+        rotation: Math.random() * Math.PI * 2,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\r\n+      })\r\n+    }\r\n \r\n-                // Mover círculo\r\n-                circle.x += circle.speedX\r\n-                circle.y += circle.speedY\r\n+    // Crear triángulos\r\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n+      const size = Math.random() * 80 + 40\r\n+      shapes.push({\r\n+        type: \"triangle\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: size,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n+        speedX: (Math.random() - 0.5) * 0.8,\r\n+        speedY: (Math.random() - 0.5) * 0.8,\r\n+        opacity: Math.random() * 0.3 + 0.15,\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: size,\r\n+        rotation: Math.random() * Math.PI * 2,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\r\n+      })\r\n+    }\r\n \r\n-                // Rebotar en los bordes\r\n-                if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n-                    circle.speedX = -circle.speedX\r\n-                }\r\n-                if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n-                    circle.speedY = -circle.speedY\r\n-                }\r\n-            })\r\n+    // Función para dibujar un círculo\r\n+    const drawCircle = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.beginPath()\r\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n \r\n-            requestAnimationFrame(animate)\r\n+      // Añadir brillo/resplandor\r\n+      ctx.beginPath()\r\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n+    }\r\n+\r\n+    // Función para dibujar un cuadrado\r\n+    const drawSquare = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.save()\r\n+      ctx.translate(shape.x, shape.y)\r\n+      ctx.rotate(shape.rotation)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\r\n+\r\n+      // Añadir brillo/resplandor\r\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.lineWidth = 8\r\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\r\n+      ctx.restore()\r\n+    }\r\n+\r\n+    // Función para dibujar un triángulo\r\n+    const drawTriangle = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.save()\r\n+      ctx.translate(shape.x, shape.y)\r\n+      ctx.rotate(shape.rotation)\r\n+      ctx.beginPath()\r\n+      ctx.moveTo(0, -shape.size / 2)\r\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\r\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\r\n+      ctx.closePath()\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n+\r\n+      // Añadir brillo/resplandor\r\n+      ctx.beginPath()\r\n+      ctx.moveTo(0, -shape.size / 2 - 10)\r\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\r\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\r\n+      ctx.closePath()\r\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.lineWidth = 5\r\n+      ctx.stroke()\r\n+      ctx.restore()\r\n+    }\r\n+\r\n+    // Función de animación\r\n+    const animate = () => {\r\n+      ctx.fillStyle = colors.background\r\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+\r\n+      // Dibujar y mover formas\r\n+      shapes.forEach((shape) => {\r\n+        // Dibujar forma según su tipo\r\n+        if (shape.type === \"circle\") {\r\n+          drawCircle(shape)\r\n+        } else if (shape.type === \"square\") {\r\n+          drawSquare(shape)\r\n+        } else if (shape.type === \"triangle\") {\r\n+          drawTriangle(shape)\r\n         }\r\n \r\n-        animate()\r\n+        // Efecto de pulsación (cambio de tamaño)\r\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\r\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\r\n+          shape.pulseDirection *= -1\r\n+        }\r\n \r\n-        return () => {\r\n-            window.removeEventListener(\"resize\", resizeCanvas)\r\n+        // Rotación para cuadrados y triángulos\r\n+        if (shape.type !== \"circle\") {\r\n+          shape.rotation += shape.rotationSpeed\r\n         }\r\n-    }, [])\r\n \r\n-    return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n+        // Mover forma\r\n+        shape.x += shape.speedX\r\n+        shape.y += shape.speedY\r\n+\r\n+        // Interacción con el cursor\r\n+        const dx = mousePosition.x - shape.x\r\n+        const dy = mousePosition.y - shape.y\r\n+        const distance = Math.sqrt(dx * dx + dy * dy)\r\n+        const maxDistance = 200\r\n+\r\n+        if (distance < maxDistance) {\r\n+          const angle = Math.atan2(dy, dx)\r\n+          const force = (maxDistance - distance) / maxDistance\r\n+          shape.x -= Math.cos(angle) * force * 2\r\n+          shape.y -= Math.sin(angle) * force * 2\r\n+        }\r\n+\r\n+        // Rebotar en los bordes\r\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\r\n+          shape.speedX = -shape.speedX\r\n+        }\r\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\r\n+          shape.speedY = -shape.speedY\r\n+        }\r\n+      })\r\n+\r\n+      requestAnimationFrame(animate)\r\n+    }\r\n+\r\n+    animate()\r\n+\r\n+    return () => {\r\n+      window.removeEventListener(\"resize\", resizeCanvas)\r\n+      window.removeEventListener(\"mousemove\", handleMouseMove)\r\n+    }\r\n+  }, [])\r\n+\r\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n }\r\n \r\n-interface Circle {\r\n-    x: number\r\n-    y: number\r\n-    radius: number\r\n-    color: string\r\n-    speedX: number\r\n-    speedY: number\r\n-    opacity: number\r\n+interface Shape {\r\n+  type: \"circle\" | \"square\" | \"triangle\"\r\n+  x: number\r\n+  y: number\r\n+  size: number\r\n+  color: string\r\n+  speedX: number\r\n+  speedY: number\r\n+  opacity: number\r\n+  pulseSpeed: number\r\n+  pulseDirection: number\r\n+  originalSize: number\r\n+  rotation: number\r\n+  rotationSpeed: number\r\n }\r\n"
                },
                {
                    "date": 1745461002225,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,253 +1,253 @@\n-\"use client\"\r\n-\r\n-import { useEffect, useRef, useState } from \"react\"\r\n-\r\n-export default function AnimatedBackground() {\r\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n-  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\r\n-\r\n-  useEffect(() => {\r\n-    const canvas = canvasRef.current\r\n-    if (!canvas) return\r\n-\r\n-    const ctx = canvas.getContext(\"2d\")\r\n-    if (!ctx) return\r\n-\r\n-    // Configurar el canvas para que ocupe toda la pantalla\r\n-    const resizeCanvas = () => {\r\n-      canvas.width = window.innerWidth\r\n-      canvas.height = window.innerHeight\r\n-    }\r\n-\r\n-    resizeCanvas()\r\n-    window.addEventListener(\"resize\", resizeCanvas)\r\n-\r\n-    // Seguimiento del cursor\r\n-    const handleMouseMove = (e: MouseEvent) => {\r\n-      setMousePosition({ x: e.clientX, y: e.clientY })\r\n-    }\r\n-    window.addEventListener(\"mousemove\", handleMouseMove)\r\n-\r\n-    // Colores minimalistas pero más vibrantes\r\n-    const colors = {\r\n-      primary: \"#38bdf8\", // Azul cielo más vibrante\r\n-      secondary: \"#4ade80\", // Verde menta más vibrante\r\n-      accent: \"#f472b6\", // Rosa más vibrante\r\n-      background: \"#f8fafc\", // Blanco grisáceo\r\n-    }\r\n-\r\n-    // Crear diferentes tipos de formas\r\n-    const shapes: Shape[] = []\r\n-    const shapeCount = 25 // Más formas para mayor dinamismo\r\n-\r\n-    // Crear círculos\r\n-    for (let i = 0; i < shapeCount * 0.6; i++) {\r\n-      const radius = Math.random() * 120 + 40\r\n-      shapes.push({\r\n-        type: \"circle\",\r\n-        x: Math.random() * canvas.width,\r\n-        y: Math.random() * canvas.height,\r\n-        size: radius,\r\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n-        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n-        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n-        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\r\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n-        pulseDirection: 1,\r\n-        originalSize: radius,\r\n-        rotation: 0,\r\n-        rotationSpeed: (Math.random() - 0.5) * 0.01,\r\n-      })\r\n-    }\r\n-\r\n-    // Crear cuadrados\r\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n-      const size = Math.random() * 100 + 30\r\n-      shapes.push({\r\n-        type: \"square\",\r\n-        x: Math.random() * canvas.width,\r\n-        y: Math.random() * canvas.height,\r\n-        size: size,\r\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n-        speedX: (Math.random() - 0.5) * 1.0,\r\n-        speedY: (Math.random() - 0.5) * 1.0,\r\n-        opacity: Math.random() * 0.3 + 0.15,\r\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n-        pulseDirection: 1,\r\n-        originalSize: size,\r\n-        rotation: Math.random() * Math.PI * 2,\r\n-        rotationSpeed: (Math.random() - 0.5) * 0.02,\r\n-      })\r\n-    }\r\n-\r\n-    // Crear triángulos\r\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n-      const size = Math.random() * 80 + 40\r\n-      shapes.push({\r\n-        type: \"triangle\",\r\n-        x: Math.random() * canvas.width,\r\n-        y: Math.random() * canvas.height,\r\n-        size: size,\r\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n-        speedX: (Math.random() - 0.5) * 0.8,\r\n-        speedY: (Math.random() - 0.5) * 0.8,\r\n-        opacity: Math.random() * 0.3 + 0.15,\r\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n-        pulseDirection: 1,\r\n-        originalSize: size,\r\n-        rotation: Math.random() * Math.PI * 2,\r\n-        rotationSpeed: (Math.random() - 0.5) * 0.015,\r\n-      })\r\n-    }\r\n-\r\n-    // Función para dibujar un círculo\r\n-    const drawCircle = (shape: Shape) => {\r\n-      if (!ctx) return\r\n-      ctx.beginPath()\r\n-      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\r\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.fill()\r\n-\r\n-      // Añadir brillo/resplandor\r\n-      ctx.beginPath()\r\n-      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\r\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.fill()\r\n-    }\r\n-\r\n-    // Función para dibujar un cuadrado\r\n-    const drawSquare = (shape: Shape) => {\r\n-      if (!ctx) return\r\n-      ctx.save()\r\n-      ctx.translate(shape.x, shape.y)\r\n-      ctx.rotate(shape.rotation)\r\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\r\n-\r\n-      // Añadir brillo/resplandor\r\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.lineWidth = 8\r\n-      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\r\n-      ctx.restore()\r\n-    }\r\n-\r\n-    // Función para dibujar un triángulo\r\n-    const drawTriangle = (shape: Shape) => {\r\n-      if (!ctx) return\r\n-      ctx.save()\r\n-      ctx.translate(shape.x, shape.y)\r\n-      ctx.rotate(shape.rotation)\r\n-      ctx.beginPath()\r\n-      ctx.moveTo(0, -shape.size / 2)\r\n-      ctx.lineTo(shape.size / 2, shape.size / 2)\r\n-      ctx.lineTo(-shape.size / 2, shape.size / 2)\r\n-      ctx.closePath()\r\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.fill()\r\n-\r\n-      // Añadir brillo/resplandor\r\n-      ctx.beginPath()\r\n-      ctx.moveTo(0, -shape.size / 2 - 10)\r\n-      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\r\n-      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\r\n-      ctx.closePath()\r\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\r\n-        .toString(16)\r\n-        .padStart(2, \"0\")}`\r\n-      ctx.lineWidth = 5\r\n-      ctx.stroke()\r\n-      ctx.restore()\r\n-    }\r\n-\r\n-    // Función de animación\r\n-    const animate = () => {\r\n-      ctx.fillStyle = colors.background\r\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n-\r\n-      // Dibujar y mover formas\r\n-      shapes.forEach((shape) => {\r\n-        // Dibujar forma según su tipo\r\n-        if (shape.type === \"circle\") {\r\n-          drawCircle(shape)\r\n-        } else if (shape.type === \"square\") {\r\n-          drawSquare(shape)\r\n-        } else if (shape.type === \"triangle\") {\r\n-          drawTriangle(shape)\r\n-        }\r\n-\r\n-        // Efecto de pulsación (cambio de tamaño)\r\n-        shape.size += shape.pulseSpeed * shape.pulseDirection\r\n-        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\r\n-          shape.pulseDirection *= -1\r\n-        }\r\n-\r\n-        // Rotación para cuadrados y triángulos\r\n-        if (shape.type !== \"circle\") {\r\n-          shape.rotation += shape.rotationSpeed\r\n-        }\r\n-\r\n-        // Mover forma\r\n-        shape.x += shape.speedX\r\n-        shape.y += shape.speedY\r\n-\r\n-        // Interacción con el cursor\r\n-        const dx = mousePosition.x - shape.x\r\n-        const dy = mousePosition.y - shape.y\r\n-        const distance = Math.sqrt(dx * dx + dy * dy)\r\n-        const maxDistance = 200\r\n-\r\n-        if (distance < maxDistance) {\r\n-          const angle = Math.atan2(dy, dx)\r\n-          const force = (maxDistance - distance) / maxDistance\r\n-          shape.x -= Math.cos(angle) * force * 2\r\n-          shape.y -= Math.sin(angle) * force * 2\r\n-        }\r\n-\r\n-        // Rebotar en los bordes\r\n-        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\r\n-          shape.speedX = -shape.speedX\r\n-        }\r\n-        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\r\n-          shape.speedY = -shape.speedY\r\n-        }\r\n-      })\r\n-\r\n-      requestAnimationFrame(animate)\r\n-    }\r\n-\r\n-    animate()\r\n-\r\n-    return () => {\r\n-      window.removeEventListener(\"resize\", resizeCanvas)\r\n-      window.removeEventListener(\"mousemove\", handleMouseMove)\r\n-    }\r\n-  }, [])\r\n-\r\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n-}\r\n-\r\n-interface Shape {\r\n-  type: \"circle\" | \"square\" | \"triangle\"\r\n-  x: number\r\n-  y: number\r\n-  size: number\r\n-  color: string\r\n-  speedX: number\r\n-  speedY: number\r\n-  opacity: number\r\n-  pulseSpeed: number\r\n-  pulseDirection: number\r\n-  originalSize: number\r\n-  rotation: number\r\n-  rotationSpeed: number\r\n-}\r\n+\"use client\"\n+\n+import { useEffect, useRef, useState } from \"react\"\n+\n+export default function AnimatedBackground() {\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current\n+    if (!canvas) return\n+\n+    const ctx = canvas.getContext(\"2d\")\n+    if (!ctx) return\n+\n+    // Configurar el canvas para que ocupe toda la pantalla\n+    const resizeCanvas = () => {\n+      canvas.width = window.innerWidth\n+      canvas.height = window.innerHeight\n+    }\n+\n+    resizeCanvas()\n+    window.addEventListener(\"resize\", resizeCanvas)\n+\n+    // Seguimiento del cursor\n+    const handleMouseMove = (e: MouseEvent) => {\n+      setMousePosition({ x: e.clientX, y: e.clientY })\n+    }\n+    window.addEventListener(\"mousemove\", handleMouseMove)\n+\n+    // Colores minimalistas pero más vibrantes\n+    const colors = {\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\n+      secondary: \"#4ade80\", // Verde menta más vibrante\n+      accent: \"#f472b6\", // Rosa más vibrante\n+      background: \"#f8fafc\", // Blanco grisáceo\n+    }\n+\n+    // Crear diferentes tipos de formas\n+    const shapes: Shape[] = []\n+    const shapeCount = 25 // Más formas para mayor dinamismo\n+\n+    // Crear círculos\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\n+      const radius = Math.random() * 120 + 40\n+      shapes.push({\n+        type: \"circle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: radius,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: radius,\n+        rotation: 0,\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\n+      })\n+    }\n+\n+    // Crear cuadrados\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 100 + 30\n+      shapes.push({\n+        type: \"square\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 1.0,\n+        speedY: (Math.random() - 0.5) * 1.0,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\n+      })\n+    }\n+\n+    // Crear triángulos\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 80 + 40\n+      shapes.push({\n+        type: \"triangle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 0.8,\n+        speedY: (Math.random() - 0.5) * 0.8,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\n+      })\n+    }\n+\n+    // Función para dibujar un círculo\n+    const drawCircle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+    }\n+\n+    // Función para dibujar un cuadrado\n+    const drawSquare = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n+\n+      // Añadir brillo/resplandor\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 8\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n+      ctx.restore()\n+    }\n+\n+    // Función para dibujar un triángulo\n+    const drawTriangle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2)\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\n+      ctx.closePath()\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2 - 10)\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n+      ctx.closePath()\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 5\n+      ctx.stroke()\n+      ctx.restore()\n+    }\n+\n+    // Función de animación\n+    const animate = () => {\n+      ctx.fillStyle = colors.background\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\n+\n+      // Dibujar y mover formas\n+      shapes.forEach((shape) => {\n+        // Dibujar forma según su tipo\n+        if (shape.type === \"circle\") {\n+          drawCircle(shape)\n+        } else if (shape.type === \"square\") {\n+          drawSquare(shape)\n+        } else if (shape.type === \"triangle\") {\n+          drawTriangle(shape)\n+        }\n+\n+        // Efecto de pulsación (cambio de tamaño)\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n+          shape.pulseDirection *= -1\n+        }\n+\n+        // Rotación para cuadrados y triángulos\n+        if (shape.type !== \"circle\") {\n+          shape.rotation += shape.rotationSpeed\n+        }\n+\n+        // Mover forma\n+        shape.x += shape.speedX\n+        shape.y += shape.speedY\n+\n+        // Interacción con el cursor\n+        const dx = mousePosition.x - shape.x\n+        const dy = mousePosition.y - shape.y\n+        const distance = Math.sqrt(dx * dx + dy * dy)\n+        const maxDistance = 200\n+\n+        if (distance < maxDistance) {\n+          const angle = Math.atan2(dy, dx)\n+          const force = (maxDistance - distance) / maxDistance\n+          shape.x -= Math.cos(angle) * force * 2\n+          shape.y -= Math.sin(angle) * force * 2\n+        }\n+\n+        // Rebotar en los bordes\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n+          shape.speedX = -shape.speedX\n+        }\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n+          shape.speedY = -shape.speedY\n+        }\n+      })\n+\n+      requestAnimationFrame(animate)\n+    }\n+\n+    animate()\n+\n+    return () => {\n+      window.removeEventListener(\"resize\", resizeCanvas)\n+      window.removeEventListener(\"mousemove\", handleMouseMove)\n+    }\n+  },)\n+\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n+}\n+\n+interface Shape {\n+  type: \"circle\" | \"square\" | \"triangle\"\n+  x: number\n+  y: number\n+  size: number\n+  color: string\n+  speedX: number\n+  speedY: number\n+  opacity: number\n+  pulseSpeed: number\n+  pulseDirection: number\n+  originalSize: number\n+  rotation: number\n+  rotationSpeed: number\n+}\n"
                },
                {
                    "date": 1745462050099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,253 @@\n+\"use client\"\n+\n+import { useEffect, useRef, useState } from \"react\"\n+\n+export default function AnimatedBackground() {\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current\n+    if (!canvas) return\n+\n+    const ctx = canvas.getContext(\"2d\")\n+    if (!ctx) return\n+\n+    // Configurar el canvas para que ocupe toda la pantalla\n+    const resizeCanvas = () => {\n+      canvas.width = window.innerWidth\n+      canvas.height = window.innerHeight\n+    }\n+\n+    resizeCanvas()\n+    window.addEventListener(\"resize\", resizeCanvas)\n+\n+    // Seguimiento del cursor\n+    const handleMouseMove = (e: MouseEvent) => {\n+      setMousePosition({ x: e.clientX, y: e.clientY })\n+    }\n+    window.addEventListener(\"mousemove\", handleMouseMove)\n+\n+    // Colores minimalistas pero más vibrantes\n+    const colors = {\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\n+      secondary: \"#4ade80\", // Verde menta más vibrante\n+      accent: \"#f472b6\", // Rosa más vibrante\n+      background: \"#f8fafc\", // Blanco grisáceo\n+    }\n+\n+    // Crear diferentes tipos de formas\n+    const shapes: Shape[] = []\n+    const shapeCount = 25 // Más formas para mayor dinamismo\n+\n+    // Crear círculos\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\n+      const radius = Math.random() * 120 + 40\n+      shapes.push({\n+        type: \"circle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: radius,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: radius,\n+        rotation: 0,\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\n+      })\n+    }\n+\n+    // Crear cuadrados\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 100 + 30\n+      shapes.push({\n+        type: \"square\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 1.0,\n+        speedY: (Math.random() - 0.5) * 1.0,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\n+      })\n+    }\n+\n+    // Crear triángulos\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 80 + 40\n+      shapes.push({\n+        type: \"triangle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 0.8,\n+        speedY: (Math.random() - 0.5) * 0.8,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\n+      })\n+    }\n+\n+    // Función para dibujar un círculo\n+    const drawCircle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+    }\n+\n+    // Función para dibujar un cuadrado\n+    const drawSquare = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n+\n+      // Añadir brillo/resplandor\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 8\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n+      ctx.restore()\n+    }\n+\n+    // Función para dibujar un triángulo\n+    const drawTriangle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2)\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\n+      ctx.closePath()\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2 - 10)\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n+      ctx.closePath()\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 5\n+      ctx.stroke()\n+      ctx.restore()\n+    }\n+\n+    // Función de animación\n+    const animate = () => {\n+      ctx.fillStyle = colors.background\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\n+\n+      // Dibujar y mover formas\n+      shapes.forEach((shape) => {\n+        // Dibujar forma según su tipo\n+        if (shape.type === \"circle\") {\n+          drawCircle(shape)\n+        } else if (shape.type === \"square\") {\n+          drawSquare(shape)\n+        } else if (shape.type === \"triangle\") {\n+          drawTriangle(shape)\n+        }\n+\n+        // Efecto de pulsación (cambio de tamaño)\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n+          shape.pulseDirection *= -1\n+        }\n+\n+        // Rotación para cuadrados y triángulos\n+        if (shape.type !== \"circle\") {\n+          shape.rotation += shape.rotationSpeed\n+        }\n+\n+        // Mover forma\n+        shape.x += shape.speedX\n+        shape.y += shape.speedY\n+\n+        // Interacción con el cursor\n+        const dx = mousePosition.x - shape.x\n+        const dy = mousePosition.y - shape.y\n+        const distance = Math.sqrt(dx * dx + dy * dy)\n+        const maxDistance = 200\n+\n+        if (distance < maxDistance) {\n+          const angle = Math.atan2(dy, dx)\n+          const force = (maxDistance - distance) / maxDistance\n+          shape.x -= Math.cos(angle) * force * 2\n+          shape.y -= Math.sin(angle) * force * 2\n+        }\n+\n+        // Rebotar en los bordes\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n+          shape.speedX = -shape.speedX\n+        }\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n+          shape.speedY = -shape.speedY\n+        }\n+      })\n+\n+      requestAnimationFrame(animate)\n+    }\n+\n+    animate()\n+\n+    return () => {\n+      window.removeEventListener(\"resize\", resizeCanvas)\n+      window.removeEventListener(\"mousemove\", handleMouseMove)\n+    }\n+  }, [canvasRef])\n+\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n+}\n+\n+interface Shape {\n+  type: \"circle\" | \"square\" | \"triangle\"\n+  x: number\n+  y: number\n+  size: number\n+  color: string\n+  speedX: number\n+  speedY: number\n+  opacity: number\n+  pulseSpeed: number\n+  pulseDirection: number\n+  originalSize: number\n+  rotation: number\n+  rotationSpeed: number\n+}\n"
                },
                {
                    "date": 1745466646671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,35 +175,13 @@\n       ctx.fillRect(0, 0, canvas.width, canvas.height)\n \n       // Dibujar y mover formas\n       shapes.forEach((shape) => {\n-        // Dibujar forma según su tipo\n-        if (shape.type === \"circle\") {\n-          drawCircle(shape)\n-        } else if (shape.type === \"square\") {\n-          drawSquare(shape)\n-        } else if (shape.type === \"triangle\") {\n-          drawTriangle(shape)\n-        }\n+        // Código de dibujo sin cambios...\n \n-        // Efecto de pulsación (cambio de tamaño)\n-        shape.size += shape.pulseSpeed * shape.pulseDirection\n-        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n-          shape.pulseDirection *= -1\n-        }\n-\n-        // Rotación para cuadrados y triángulos\n-        if (shape.type !== \"circle\") {\n-          shape.rotation += shape.rotationSpeed\n-        }\n-\n-        // Mover forma\n-        shape.x += shape.speedX\n-        shape.y += shape.speedY\n-\n-        // Interacción con el cursor\n-        const dx = mousePosition.x - shape.x\n-        const dy = mousePosition.y - shape.y\n+        // Interacción con el cursor - ahora usando mousePositionRef.current\n+        const dx = mousePositionRef.current.x - shape.x\n+        const dy = mousePositionRef.current.y - shape.y\n         const distance = Math.sqrt(dx * dx + dy * dy)\n         const maxDistance = 200\n \n         if (distance < maxDistance) {\n@@ -212,15 +190,9 @@\n           shape.x -= Math.cos(angle) * force * 2\n           shape.y -= Math.sin(angle) * force * 2\n         }\n \n-        // Rebotar en los bordes\n-        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n-          shape.speedX = -shape.speedX\n-        }\n-        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n-          shape.speedY = -shape.speedY\n-        }\n+        // Resto del código sin cambios...\n       })\n \n       requestAnimationFrame(animate)\n     }\n@@ -230,9 +202,9 @@\n     return () => {\n       window.removeEventListener(\"resize\", resizeCanvas)\n       window.removeEventListener(\"mousemove\", handleMouseMove)\n     }\n-  }, [canvasRef])\n+  }, [canvasRef]) // Ahora solo depende de canvasRef\n \n   return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n }\n \n@@ -250,257 +222,4 @@\n   originalSize: number\n   rotation: number\n   rotationSpeed: number\n }\n-\"use client\"\n-\n-import { useEffect, useRef, useState } from \"react\"\n-\n-export default function AnimatedBackground() {\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\n-  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n-\n-  useEffect(() => {\n-    const canvas = canvasRef.current\n-    if (!canvas) return\n-\n-    const ctx = canvas.getContext(\"2d\")\n-    if (!ctx) return\n-\n-    // Configurar el canvas para que ocupe toda la pantalla\n-    const resizeCanvas = () => {\n-      canvas.width = window.innerWidth\n-      canvas.height = window.innerHeight\n-    }\n-\n-    resizeCanvas()\n-    window.addEventListener(\"resize\", resizeCanvas)\n-\n-    // Seguimiento del cursor\n-    const handleMouseMove = (e: MouseEvent) => {\n-      setMousePosition({ x: e.clientX, y: e.clientY })\n-    }\n-    window.addEventListener(\"mousemove\", handleMouseMove)\n-\n-    // Colores minimalistas pero más vibrantes\n-    const colors = {\n-      primary: \"#38bdf8\", // Azul cielo más vibrante\n-      secondary: \"#4ade80\", // Verde menta más vibrante\n-      accent: \"#f472b6\", // Rosa más vibrante\n-      background: \"#f8fafc\", // Blanco grisáceo\n-    }\n-\n-    // Crear diferentes tipos de formas\n-    const shapes: Shape[] = []\n-    const shapeCount = 25 // Más formas para mayor dinamismo\n-\n-    // Crear círculos\n-    for (let i = 0; i < shapeCount * 0.6; i++) {\n-      const radius = Math.random() * 120 + 40\n-      shapes.push({\n-        type: \"circle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: radius,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n-        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: radius,\n-        rotation: 0,\n-        rotationSpeed: (Math.random() - 0.5) * 0.01,\n-      })\n-    }\n-\n-    // Crear cuadrados\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 100 + 30\n-      shapes.push({\n-        type: \"square\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 1.0,\n-        speedY: (Math.random() - 0.5) * 1.0,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.02,\n-      })\n-    }\n-\n-    // Crear triángulos\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 80 + 40\n-      shapes.push({\n-        type: \"triangle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 0.8,\n-        speedY: (Math.random() - 0.5) * 0.8,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.015,\n-      })\n-    }\n-\n-    // Función para dibujar un círculo\n-    const drawCircle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-    }\n-\n-    // Función para dibujar un cuadrado\n-    const drawSquare = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n-\n-      // Añadir brillo/resplandor\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 8\n-      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n-      ctx.restore()\n-    }\n-\n-    // Función para dibujar un triángulo\n-    const drawTriangle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2)\n-      ctx.lineTo(shape.size / 2, shape.size / 2)\n-      ctx.lineTo(-shape.size / 2, shape.size / 2)\n-      ctx.closePath()\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2 - 10)\n-      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n-      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n-      ctx.closePath()\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 5\n-      ctx.stroke()\n-      ctx.restore()\n-    }\n-\n-    // Función de animación\n-    const animate = () => {\n-      ctx.fillStyle = colors.background\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\n-\n-      // Dibujar y mover formas\n-      shapes.forEach((shape) => {\n-        // Dibujar forma según su tipo\n-        if (shape.type === \"circle\") {\n-          drawCircle(shape)\n-        } else if (shape.type === \"square\") {\n-          drawSquare(shape)\n-        } else if (shape.type === \"triangle\") {\n-          drawTriangle(shape)\n-        }\n-\n-        // Efecto de pulsación (cambio de tamaño)\n-        shape.size += shape.pulseSpeed * shape.pulseDirection\n-        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n-          shape.pulseDirection *= -1\n-        }\n-\n-        // Rotación para cuadrados y triángulos\n-        if (shape.type !== \"circle\") {\n-          shape.rotation += shape.rotationSpeed\n-        }\n-\n-        // Mover forma\n-        shape.x += shape.speedX\n-        shape.y += shape.speedY\n-\n-        // Interacción con el cursor\n-        const dx = mousePosition.x - shape.x\n-        const dy = mousePosition.y - shape.y\n-        const distance = Math.sqrt(dx * dx + dy * dy)\n-        const maxDistance = 200\n-\n-        if (distance < maxDistance) {\n-          const angle = Math.atan2(dy, dx)\n-          const force = (maxDistance - distance) / maxDistance\n-          shape.x -= Math.cos(angle) * force * 2\n-          shape.y -= Math.sin(angle) * force * 2\n-        }\n-\n-        // Rebotar en los bordes\n-        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n-          shape.speedX = -shape.speedX\n-        }\n-        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n-          shape.speedY = -shape.speedY\n-        }\n-      })\n-\n-      requestAnimationFrame(animate)\n-    }\n-\n-    animate()\n-\n-    return () => {\n-      window.removeEventListener(\"resize\", resizeCanvas)\n-      window.removeEventListener(\"mousemove\", handleMouseMove)\n-    }\n-  },)\n-\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n-}\n-\n-interface Shape {\n-  type: \"circle\" | \"square\" | \"triangle\"\n-  x: number\n-  y: number\n-  size: number\n-  color: string\n-  speedX: number\n-  speedY: number\n-  opacity: number\n-  pulseSpeed: number\n-  pulseDirection: number\n-  originalSize: number\n-  rotation: number\n-  rotationSpeed: number\n-}\n"
                },
                {
                    "date": 1745466673414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,12 @@\n \"use client\"\n \n-import { useEffect, useRef, useState } from \"react\"\n+import { useEffect, useRef } from \"react\"\n \n export default function AnimatedBackground() {\n   const canvasRef = useRef<HTMLCanvasElement>(null)\n-  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n+  // Cambiamos a useRef para evitar re-renderizaciones\n+  const mousePositionRef = useRef({ x: 0, y: 0 })\n \n   useEffect(() => {\n     const canvas = canvasRef.current\n     if (!canvas) return\n@@ -21,11 +22,11 @@\n \n     resizeCanvas()\n     window.addEventListener(\"resize\", resizeCanvas)\n \n-    // Seguimiento del cursor\n+    // Seguimiento del cursor - actualiza la referencia en lugar del estado\n     const handleMouseMove = (e: MouseEvent) => {\n-      setMousePosition({ x: e.clientX, y: e.clientY })\n+      mousePositionRef.current = { x: e.clientX, y: e.clientY }\n     }\n     window.addEventListener(\"mousemove\", handleMouseMove)\n \n     // Colores minimalistas pero más vibrantes\n"
                },
                {
                    "date": 1745466719896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,11 @@\n \"use client\"\n \n-import { useEffect, useRef } from \"react\"\n+import { useEffect, useRef, useState } from \"react\"\n \n export default function AnimatedBackground() {\n   const canvasRef = useRef<HTMLCanvasElement>(null)\n-  // Cambiamos a useRef para evitar re-renderizaciones\n-  const mousePositionRef = useRef({ x: 0, y: 0 })\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n \n   useEffect(() => {\n     const canvas = canvasRef.current\n     if (!canvas) return\n@@ -22,11 +21,11 @@\n \n     resizeCanvas()\n     window.addEventListener(\"resize\", resizeCanvas)\n \n-    // Seguimiento del cursor - actualiza la referencia en lugar del estado\n+    // Seguimiento del cursor\n     const handleMouseMove = (e: MouseEvent) => {\n-      mousePositionRef.current = { x: e.clientX, y: e.clientY }\n+      setMousePosition({ x: e.clientX, y: e.clientY })\n     }\n     window.addEventListener(\"mousemove\", handleMouseMove)\n \n     // Colores minimalistas pero más vibrantes\n"
                },
                {
                    "date": 1745466735021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,13 +22,10 @@\n     resizeCanvas()\n     window.addEventListener(\"resize\", resizeCanvas)\n \n     // Seguimiento del cursor\n-    const handleMouseMove = (e: MouseEvent) => {\n-      setMousePosition({ x: e.clientX, y: e.clientY })\n-    }\n-    window.addEventListener(\"mousemove\", handleMouseMove)\n \n+\n     // Colores minimalistas pero más vibrantes\n     const colors = {\n       primary: \"#38bdf8\", // Azul cielo más vibrante\n       secondary: \"#4ade80\", // Verde menta más vibrante\n@@ -175,13 +172,35 @@\n       ctx.fillRect(0, 0, canvas.width, canvas.height)\n \n       // Dibujar y mover formas\n       shapes.forEach((shape) => {\n-        // Código de dibujo sin cambios...\n+        // Dibujar forma según su tipo\n+        if (shape.type === \"circle\") {\n+          drawCircle(shape)\n+        } else if (shape.type === \"square\") {\n+          drawSquare(shape)\n+        } else if (shape.type === \"triangle\") {\n+          drawTriangle(shape)\n+        }\n \n-        // Interacción con el cursor - ahora usando mousePositionRef.current\n-        const dx = mousePositionRef.current.x - shape.x\n-        const dy = mousePositionRef.current.y - shape.y\n+        // Efecto de pulsación (cambio de tamaño)\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n+          shape.pulseDirection *= -1\n+        }\n+\n+        // Rotación para cuadrados y triángulos\n+        if (shape.type !== \"circle\") {\n+          shape.rotation += shape.rotationSpeed\n+        }\n+\n+        // Mover forma\n+        shape.x += shape.speedX\n+        shape.y += shape.speedY\n+\n+        // Interacción con el cursor\n+        const dx = mousePosition.x - shape.x\n+        const dy = mousePosition.y - shape.y\n         const distance = Math.sqrt(dx * dx + dy * dy)\n         const maxDistance = 200\n \n         if (distance < maxDistance) {\n@@ -190,9 +209,15 @@\n           shape.x -= Math.cos(angle) * force * 2\n           shape.y -= Math.sin(angle) * force * 2\n         }\n \n-        // Resto del código sin cambios...\n+        // Rebotar en los bordes\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n+          shape.speedX = -shape.speedX\n+        }\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n+          shape.speedY = -shape.speedY\n+        }\n       })\n \n       requestAnimationFrame(animate)\n     }\n@@ -202,9 +227,9 @@\n     return () => {\n       window.removeEventListener(\"resize\", resizeCanvas)\n       window.removeEventListener(\"mousemove\", handleMouseMove)\n     }\n-  }, [canvasRef]) // Ahora solo depende de canvasRef\n+  }, [canvasRef])\n \n   return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n }\n \n"
                },
                {
                    "date": 1745466740384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,250 @@\n+\"use client\"\n+\n+import { useEffect, useRef, useState } from \"react\"\n+\n+export default function AnimatedBackground() {\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current\n+    if (!canvas) return\n+\n+    const ctx = canvas.getContext(\"2d\")\n+    if (!ctx) return\n+\n+    // Configurar el canvas para que ocupe toda la pantalla\n+    const resizeCanvas = () => {\n+      canvas.width = window.innerWidth\n+      canvas.height = window.innerHeight\n+    }\n+\n+    resizeCanvas()\n+    window.addEventListener(\"resize\", resizeCanvas)\n+\n+    // Seguimiento del cursor\n+\n+\n+    // Colores minimalistas pero más vibrantes\n+    const colors = {\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\n+      secondary: \"#4ade80\", // Verde menta más vibrante\n+      accent: \"#f472b6\", // Rosa más vibrante\n+      background: \"#f8fafc\", // Blanco grisáceo\n+    }\n+\n+    // Crear diferentes tipos de formas\n+    const shapes: Shape[] = []\n+    const shapeCount = 25 // Más formas para mayor dinamismo\n+\n+    // Crear círculos\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\n+      const radius = Math.random() * 120 + 40\n+      shapes.push({\n+        type: \"circle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: radius,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: radius,\n+        rotation: 0,\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\n+      })\n+    }\n+\n+    // Crear cuadrados\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 100 + 30\n+      shapes.push({\n+        type: \"square\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 1.0,\n+        speedY: (Math.random() - 0.5) * 1.0,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\n+      })\n+    }\n+\n+    // Crear triángulos\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 80 + 40\n+      shapes.push({\n+        type: \"triangle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 0.8,\n+        speedY: (Math.random() - 0.5) * 0.8,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\n+      })\n+    }\n+\n+    // Función para dibujar un círculo\n+    const drawCircle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+    }\n+\n+    // Función para dibujar un cuadrado\n+    const drawSquare = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n+\n+      // Añadir brillo/resplandor\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 8\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n+      ctx.restore()\n+    }\n+\n+    // Función para dibujar un triángulo\n+    const drawTriangle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2)\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\n+      ctx.closePath()\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2 - 10)\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n+      ctx.closePath()\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 5\n+      ctx.stroke()\n+      ctx.restore()\n+    }\n+\n+    // Función de animación\n+    const animate = () => {\n+      ctx.fillStyle = colors.background\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\n+\n+      // Dibujar y mover formas\n+      shapes.forEach((shape) => {\n+        // Dibujar forma según su tipo\n+        if (shape.type === \"circle\") {\n+          drawCircle(shape)\n+        } else if (shape.type === \"square\") {\n+          drawSquare(shape)\n+        } else if (shape.type === \"triangle\") {\n+          drawTriangle(shape)\n+        }\n+\n+        // Efecto de pulsación (cambio de tamaño)\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n+          shape.pulseDirection *= -1\n+        }\n+\n+        // Rotación para cuadrados y triángulos\n+        if (shape.type !== \"circle\") {\n+          shape.rotation += shape.rotationSpeed\n+        }\n+\n+        // Mover forma\n+        shape.x += shape.speedX\n+        shape.y += shape.speedY\n+\n+        // Interacción con el cursor\n+        const dx = mousePosition.x - shape.x\n+        const dy = mousePosition.y - shape.y\n+        const distance = Math.sqrt(dx * dx + dy * dy)\n+        const maxDistance = 200\n+\n+        if (distance < maxDistance) {\n+          const angle = Math.atan2(dy, dx)\n+          const force = (maxDistance - distance) / maxDistance\n+          shape.x -= Math.cos(angle) * force * 2\n+          shape.y -= Math.sin(angle) * force * 2\n+        }\n+\n+        // Rebotar en los bordes\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n+          shape.speedX = -shape.speedX\n+        }\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n+          shape.speedY = -shape.speedY\n+        }\n+      })\n+\n+      requestAnimationFrame(animate)\n+    }\n+\n+    animate()\n+\n+    return () => {\n+      window.removeEventListener(\"resize\", resizeCanvas)\n+  \n+    }\n+  }, [canvasRef])\n+\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n+}\n+\n+interface Shape {\n+  type: \"circle\" | \"square\" | \"triangle\"\n+  x: number\n+  y: number\n+  size: number\n+  color: string\n+  speedX: number\n+  speedY: number\n+  opacity: number\n+  pulseSpeed: number\n+  pulseDirection: number\n+  originalSize: number\n+  rotation: number\n+  rotationSpeed: number\n+}\n"
                },
                {
                    "date": 1745466788143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,250 @@\n+\"use client\"\n+\n+import { useEffect, useRef, useState } from \"react\"\n+\n+export default function AnimatedBackground() {\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\n+  const [mousePosition] = useState({ x: 0, y: 0 })\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current\n+    if (!canvas) return\n+\n+    const ctx = canvas.getContext(\"2d\")\n+    if (!ctx) return\n+\n+    // Configurar el canvas para que ocupe toda la pantalla\n+    const resizeCanvas = () => {\n+      canvas.width = window.innerWidth\n+      canvas.height = window.innerHeight\n+    }\n+\n+    resizeCanvas()\n+    window.addEventListener(\"resize\", resizeCanvas)\n+\n+    // Seguimiento del cursor\n+\n+\n+    // Colores minimalistas pero más vibrantes\n+    const colors = {\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\n+      secondary: \"#4ade80\", // Verde menta más vibrante\n+      accent: \"#f472b6\", // Rosa más vibrante\n+      background: \"#f8fafc\", // Blanco grisáceo\n+    }\n+\n+    // Crear diferentes tipos de formas\n+    const shapes: Shape[] = []\n+    const shapeCount = 25 // Más formas para mayor dinamismo\n+\n+    // Crear círculos\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\n+      const radius = Math.random() * 120 + 40\n+      shapes.push({\n+        type: \"circle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: radius,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: radius,\n+        rotation: 0,\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\n+      })\n+    }\n+\n+    // Crear cuadrados\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 100 + 30\n+      shapes.push({\n+        type: \"square\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 1.0,\n+        speedY: (Math.random() - 0.5) * 1.0,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\n+      })\n+    }\n+\n+    // Crear triángulos\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\n+      const size = Math.random() * 80 + 40\n+      shapes.push({\n+        type: \"triangle\",\n+        x: Math.random() * canvas.width,\n+        y: Math.random() * canvas.height,\n+        size: size,\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n+        speedX: (Math.random() - 0.5) * 0.8,\n+        speedY: (Math.random() - 0.5) * 0.8,\n+        opacity: Math.random() * 0.3 + 0.15,\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\n+        pulseDirection: 1,\n+        originalSize: size,\n+        rotation: Math.random() * Math.PI * 2,\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\n+      })\n+    }\n+\n+    // Función para dibujar un círculo\n+    const drawCircle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+    }\n+\n+    // Función para dibujar un cuadrado\n+    const drawSquare = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n+\n+      // Añadir brillo/resplandor\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 8\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n+      ctx.restore()\n+    }\n+\n+    // Función para dibujar un triángulo\n+    const drawTriangle = (shape: Shape) => {\n+      if (!ctx) return\n+      ctx.save()\n+      ctx.translate(shape.x, shape.y)\n+      ctx.rotate(shape.rotation)\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2)\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\n+      ctx.closePath()\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.fill()\n+\n+      // Añadir brillo/resplandor\n+      ctx.beginPath()\n+      ctx.moveTo(0, -shape.size / 2 - 10)\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n+      ctx.closePath()\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n+        .toString(16)\n+        .padStart(2, \"0\")}`\n+      ctx.lineWidth = 5\n+      ctx.stroke()\n+      ctx.restore()\n+    }\n+\n+    // Función de animación\n+    const animate = () => {\n+      ctx.fillStyle = colors.background\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\n+\n+      // Dibujar y mover formas\n+      shapes.forEach((shape) => {\n+        // Dibujar forma según su tipo\n+        if (shape.type === \"circle\") {\n+          drawCircle(shape)\n+        } else if (shape.type === \"square\") {\n+          drawSquare(shape)\n+        } else if (shape.type === \"triangle\") {\n+          drawTriangle(shape)\n+        }\n+\n+        // Efecto de pulsación (cambio de tamaño)\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n+          shape.pulseDirection *= -1\n+        }\n+\n+        // Rotación para cuadrados y triángulos\n+        if (shape.type !== \"circle\") {\n+          shape.rotation += shape.rotationSpeed\n+        }\n+\n+        // Mover forma\n+        shape.x += shape.speedX\n+        shape.y += shape.speedY\n+\n+        // Interacción con el cursor\n+        const dx = mousePosition.x - shape.x\n+        const dy = mousePosition.y - shape.y\n+        const distance = Math.sqrt(dx * dx + dy * dy)\n+        const maxDistance = 200\n+\n+        if (distance < maxDistance) {\n+          const angle = Math.atan2(dy, dx)\n+          const force = (maxDistance - distance) / maxDistance\n+          shape.x -= Math.cos(angle) * force * 2\n+          shape.y -= Math.sin(angle) * force * 2\n+        }\n+\n+        // Rebotar en los bordes\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n+          shape.speedX = -shape.speedX\n+        }\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n+          shape.speedY = -shape.speedY\n+        }\n+      })\n+\n+      requestAnimationFrame(animate)\n+    }\n+\n+    animate()\n+\n+    return () => {\n+      window.removeEventListener(\"resize\", resizeCanvas)\n+  \n+    }\n+  }, [canvasRef])\n+\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n+}\n+\n+interface Shape {\n+  type: \"circle\" | \"square\" | \"triangle\"\n+  x: number\n+  y: number\n+  size: number\n+  color: string\n+  speedX: number\n+  speedY: number\n+  opacity: number\n+  pulseSpeed: number\n+  pulseDirection: number\n+  originalSize: number\n+  rotation: number\n+  rotationSpeed: number\n+}\n"
                },
                {
                    "date": 1745466799782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -227,9 +227,9 @@\n     return () => {\n       window.removeEventListener(\"resize\", resizeCanvas)\n   \n     }\n-  }, [canvasRef])\n+  }, [])\n \n   return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n }\n \n@@ -247,504 +247,4 @@\n   originalSize: number\n   rotation: number\n   rotationSpeed: number\n }\n-\"use client\"\n-\n-import { useEffect, useRef, useState } from \"react\"\n-\n-export default function AnimatedBackground() {\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\n-  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n-\n-  useEffect(() => {\n-    const canvas = canvasRef.current\n-    if (!canvas) return\n-\n-    const ctx = canvas.getContext(\"2d\")\n-    if (!ctx) return\n-\n-    // Configurar el canvas para que ocupe toda la pantalla\n-    const resizeCanvas = () => {\n-      canvas.width = window.innerWidth\n-      canvas.height = window.innerHeight\n-    }\n-\n-    resizeCanvas()\n-    window.addEventListener(\"resize\", resizeCanvas)\n-\n-    // Seguimiento del cursor\n-\n-\n-    // Colores minimalistas pero más vibrantes\n-    const colors = {\n-      primary: \"#38bdf8\", // Azul cielo más vibrante\n-      secondary: \"#4ade80\", // Verde menta más vibrante\n-      accent: \"#f472b6\", // Rosa más vibrante\n-      background: \"#f8fafc\", // Blanco grisáceo\n-    }\n-\n-    // Crear diferentes tipos de formas\n-    const shapes: Shape[] = []\n-    const shapeCount = 25 // Más formas para mayor dinamismo\n-\n-    // Crear círculos\n-    for (let i = 0; i < shapeCount * 0.6; i++) {\n-      const radius = Math.random() * 120 + 40\n-      shapes.push({\n-        type: \"circle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: radius,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n-        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: radius,\n-        rotation: 0,\n-        rotationSpeed: (Math.random() - 0.5) * 0.01,\n-      })\n-    }\n-\n-    // Crear cuadrados\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 100 + 30\n-      shapes.push({\n-        type: \"square\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 1.0,\n-        speedY: (Math.random() - 0.5) * 1.0,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.02,\n-      })\n-    }\n-\n-    // Crear triángulos\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 80 + 40\n-      shapes.push({\n-        type: \"triangle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 0.8,\n-        speedY: (Math.random() - 0.5) * 0.8,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.015,\n-      })\n-    }\n-\n-    // Función para dibujar un círculo\n-    const drawCircle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-    }\n-\n-    // Función para dibujar un cuadrado\n-    const drawSquare = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n-\n-      // Añadir brillo/resplandor\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 8\n-      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n-      ctx.restore()\n-    }\n-\n-    // Función para dibujar un triángulo\n-    const drawTriangle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2)\n-      ctx.lineTo(shape.size / 2, shape.size / 2)\n-      ctx.lineTo(-shape.size / 2, shape.size / 2)\n-      ctx.closePath()\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2 - 10)\n-      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n-      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n-      ctx.closePath()\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 5\n-      ctx.stroke()\n-      ctx.restore()\n-    }\n-\n-    // Función de animación\n-    const animate = () => {\n-      ctx.fillStyle = colors.background\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\n-\n-      // Dibujar y mover formas\n-      shapes.forEach((shape) => {\n-        // Dibujar forma según su tipo\n-        if (shape.type === \"circle\") {\n-          drawCircle(shape)\n-        } else if (shape.type === \"square\") {\n-          drawSquare(shape)\n-        } else if (shape.type === \"triangle\") {\n-          drawTriangle(shape)\n-        }\n-\n-        // Efecto de pulsación (cambio de tamaño)\n-        shape.size += shape.pulseSpeed * shape.pulseDirection\n-        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n-          shape.pulseDirection *= -1\n-        }\n-\n-        // Rotación para cuadrados y triángulos\n-        if (shape.type !== \"circle\") {\n-          shape.rotation += shape.rotationSpeed\n-        }\n-\n-        // Mover forma\n-        shape.x += shape.speedX\n-        shape.y += shape.speedY\n-\n-        // Interacción con el cursor\n-        const dx = mousePosition.x - shape.x\n-        const dy = mousePosition.y - shape.y\n-        const distance = Math.sqrt(dx * dx + dy * dy)\n-        const maxDistance = 200\n-\n-        if (distance < maxDistance) {\n-          const angle = Math.atan2(dy, dx)\n-          const force = (maxDistance - distance) / maxDistance\n-          shape.x -= Math.cos(angle) * force * 2\n-          shape.y -= Math.sin(angle) * force * 2\n-        }\n-\n-        // Rebotar en los bordes\n-        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n-          shape.speedX = -shape.speedX\n-        }\n-        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n-          shape.speedY = -shape.speedY\n-        }\n-      })\n-\n-      requestAnimationFrame(animate)\n-    }\n-\n-    animate()\n-\n-    return () => {\n-      window.removeEventListener(\"resize\", resizeCanvas)\n-  \n-    }\n-  }, [canvasRef])\n-\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n-}\n-\n-interface Shape {\n-  type: \"circle\" | \"square\" | \"triangle\"\n-  x: number\n-  y: number\n-  size: number\n-  color: string\n-  speedX: number\n-  speedY: number\n-  opacity: number\n-  pulseSpeed: number\n-  pulseDirection: number\n-  originalSize: number\n-  rotation: number\n-  rotationSpeed: number\n-}\n-\"use client\"\n-\n-import { useEffect, useRef, useState } from \"react\"\n-\n-export default function AnimatedBackground() {\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\n-  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\n-\n-  useEffect(() => {\n-    const canvas = canvasRef.current\n-    if (!canvas) return\n-\n-    const ctx = canvas.getContext(\"2d\")\n-    if (!ctx) return\n-\n-    // Configurar el canvas para que ocupe toda la pantalla\n-    const resizeCanvas = () => {\n-      canvas.width = window.innerWidth\n-      canvas.height = window.innerHeight\n-    }\n-\n-    resizeCanvas()\n-    window.addEventListener(\"resize\", resizeCanvas)\n-\n-    // Seguimiento del cursor\n-\n-\n-    // Colores minimalistas pero más vibrantes\n-    const colors = {\n-      primary: \"#38bdf8\", // Azul cielo más vibrante\n-      secondary: \"#4ade80\", // Verde menta más vibrante\n-      accent: \"#f472b6\", // Rosa más vibrante\n-      background: \"#f8fafc\", // Blanco grisáceo\n-    }\n-\n-    // Crear diferentes tipos de formas\n-    const shapes: Shape[] = []\n-    const shapeCount = 25 // Más formas para mayor dinamismo\n-\n-    // Crear círculos\n-    for (let i = 0; i < shapeCount * 0.6; i++) {\n-      const radius = Math.random() * 120 + 40\n-      shapes.push({\n-        type: \"circle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: radius,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\n-        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\n-        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: radius,\n-        rotation: 0,\n-        rotationSpeed: (Math.random() - 0.5) * 0.01,\n-      })\n-    }\n-\n-    // Crear cuadrados\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 100 + 30\n-      shapes.push({\n-        type: \"square\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 1.0,\n-        speedY: (Math.random() - 0.5) * 1.0,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.02,\n-      })\n-    }\n-\n-    // Crear triángulos\n-    for (let i = 0; i < shapeCount * 0.2; i++) {\n-      const size = Math.random() * 80 + 40\n-      shapes.push({\n-        type: \"triangle\",\n-        x: Math.random() * canvas.width,\n-        y: Math.random() * canvas.height,\n-        size: size,\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)],\n-        speedX: (Math.random() - 0.5) * 0.8,\n-        speedY: (Math.random() - 0.5) * 0.8,\n-        opacity: Math.random() * 0.3 + 0.15,\n-        pulseSpeed: Math.random() * 0.02 + 0.01,\n-        pulseDirection: 1,\n-        originalSize: size,\n-        rotation: Math.random() * Math.PI * 2,\n-        rotationSpeed: (Math.random() - 0.5) * 0.015,\n-      })\n-    }\n-\n-    // Función para dibujar un círculo\n-    const drawCircle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-    }\n-\n-    // Función para dibujar un cuadrado\n-    const drawSquare = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\n-\n-      // Añadir brillo/resplandor\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 8\n-      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\n-      ctx.restore()\n-    }\n-\n-    // Función para dibujar un triángulo\n-    const drawTriangle = (shape: Shape) => {\n-      if (!ctx) return\n-      ctx.save()\n-      ctx.translate(shape.x, shape.y)\n-      ctx.rotate(shape.rotation)\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2)\n-      ctx.lineTo(shape.size / 2, shape.size / 2)\n-      ctx.lineTo(-shape.size / 2, shape.size / 2)\n-      ctx.closePath()\n-      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.fill()\n-\n-      // Añadir brillo/resplandor\n-      ctx.beginPath()\n-      ctx.moveTo(0, -shape.size / 2 - 10)\n-      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\n-      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\n-      ctx.closePath()\n-      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\n-        .toString(16)\n-        .padStart(2, \"0\")}`\n-      ctx.lineWidth = 5\n-      ctx.stroke()\n-      ctx.restore()\n-    }\n-\n-    // Función de animación\n-    const animate = () => {\n-      ctx.fillStyle = colors.background\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\n-\n-      // Dibujar y mover formas\n-      shapes.forEach((shape) => {\n-        // Dibujar forma según su tipo\n-        if (shape.type === \"circle\") {\n-          drawCircle(shape)\n-        } else if (shape.type === \"square\") {\n-          drawSquare(shape)\n-        } else if (shape.type === \"triangle\") {\n-          drawTriangle(shape)\n-        }\n-\n-        // Efecto de pulsación (cambio de tamaño)\n-        shape.size += shape.pulseSpeed * shape.pulseDirection\n-        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\n-          shape.pulseDirection *= -1\n-        }\n-\n-        // Rotación para cuadrados y triángulos\n-        if (shape.type !== \"circle\") {\n-          shape.rotation += shape.rotationSpeed\n-        }\n-\n-        // Mover forma\n-        shape.x += shape.speedX\n-        shape.y += shape.speedY\n-\n-        // Interacción con el cursor\n-        const dx = mousePosition.x - shape.x\n-        const dy = mousePosition.y - shape.y\n-        const distance = Math.sqrt(dx * dx + dy * dy)\n-        const maxDistance = 200\n-\n-        if (distance < maxDistance) {\n-          const angle = Math.atan2(dy, dx)\n-          const force = (maxDistance - distance) / maxDistance\n-          shape.x -= Math.cos(angle) * force * 2\n-          shape.y -= Math.sin(angle) * force * 2\n-        }\n-\n-        // Rebotar en los bordes\n-        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\n-          shape.speedX = -shape.speedX\n-        }\n-        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\n-          shape.speedY = -shape.speedY\n-        }\n-      })\n-\n-      requestAnimationFrame(animate)\n-    }\n-\n-    animate()\n-\n-    return () => {\n-      window.removeEventListener(\"resize\", resizeCanvas)\n-      window.removeEventListener(\"mousemove\", handleMouseMove)\n-    }\n-  }, [canvasRef])\n-\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n-}\n-\n-interface Shape {\n-  type: \"circle\" | \"square\" | \"triangle\"\n-  x: number\n-  y: number\n-  size: number\n-  color: string\n-  speedX: number\n-  speedY: number\n-  opacity: number\n-  pulseSpeed: number\n-  pulseDirection: number\n-  originalSize: number\n-  rotation: number\n-  rotationSpeed: number\n-}\n"
                },
                {
                    "date": 1745466842994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -227,9 +227,9 @@\n     return () => {\n       window.removeEventListener(\"resize\", resizeCanvas)\n   \n     }\n-  }, [])\n+  },[])\n \n   return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\n }\n \n"
                }
            ],
            "date": 1745196762391,
            "name": "Commit-0",
            "content": "\"use client\"\r\n\r\nimport { useEffect, useRef } from \"react\"\r\n\r\nexport default function AnimatedBackground() {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current\r\n    if (!canvas) return\r\n\r\n    const ctx = canvas.getContext(\"2d\")\r\n    if (!ctx) return\r\n\r\n    // Configurar el canvas para que ocupe toda la pantalla\r\n    const resizeCanvas = () => {\r\n      canvas.width = window.innerWidth\r\n      canvas.height = window.innerHeight\r\n    }\r\n\r\n    resizeCanvas()\r\n    window.addEventListener(\"resize\", resizeCanvas)\r\n\r\n    // Colores minimalistas\r\n    const colors = {\r\n      primary: \"#e0f2fe\", // Azul claro\r\n      secondary: \"#dcfce7\", // Verde menta\r\n      accent: \"#fce7f3\", // Rosa pálido\r\n      background: \"#f8fafc\", // Blanco grisáceo\r\n    }\r\n\r\n    // Crear círculos con diferentes colores y tamaños\r\n    const circles: Circle[] = []\r\n    const circleCount = 15\r\n\r\n    for (let i = 0; i < circleCount; i++) {\r\n      const radius = Math.random() * 150 + 50\r\n      circles.push({\r\n        x: Math.random() * canvas.width,\r\n        y: Math.random() * canvas.height,\r\n        radius,\r\n        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n        speedX: (Math.random() - 0.5) * 0.3,\r\n        speedY: (Math.random() - 0.5) * 0.3,\r\n        opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n      })\r\n    }\r\n\r\n    // Función de animación\r\n    const animate = () => {\r\n      ctx.fillStyle = colors.background\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n      // Dibujar y mover círculos\r\n      circles.forEach((circle) => {\r\n        ctx.beginPath()\r\n        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n        ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n          .toString(16)\r\n          .padStart(2, \"0\")}`\r\n        ctx.fill()\r\n\r\n        // Mover círculo\r\n        circle.x += circle.speedX\r\n        circle.y += circle.speedY\r\n\r\n        // Rebotar en los bordes\r\n        if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n          circle.speedX = -circle.speedX\r\n        }\r\n        if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n          circle.speedY = -circle.speedY\r\n        }\r\n      })\r\n\r\n      requestAnimationFrame(animate)\r\n    }\r\n\r\n    animate()\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", resizeCanvas)\r\n    }\r\n  }, [])\r\n\r\n  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n}\r\n\r\ninterface Circle {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  color: string\r\n  speedX: number\r\n  speedY: number\r\n  opacity: number\r\n}\r\n"
        }
    ]
}