{
    "sourceFile": "src/components/logind/animation.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1745196762391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745196771734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,96 +2,96 @@\n \r\n import { useEffect, useRef } from \"react\"\r\n \r\n export default function AnimatedBackground() {\r\n-  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+    const canvasRef = useRef<HTMLCanvasElement>(null)\r\n \r\n-  useEffect(() => {\r\n-    const canvas = canvasRef.current\r\n-    if (!canvas) return\r\n+    useEffect(() => {\r\n+        const canvas = canvasRef.current\r\n+        if (!canvas) return\r\n \r\n-    const ctx = canvas.getContext(\"2d\")\r\n-    if (!ctx) return\r\n+        const ctx = canvas.getContext(\"2d\")\r\n+        if (!ctx) return\r\n \r\n-    // Configurar el canvas para que ocupe toda la pantalla\r\n-    const resizeCanvas = () => {\r\n-      canvas.width = window.innerWidth\r\n-      canvas.height = window.innerHeight\r\n-    }\r\n+       \r\n+        const resizeCanvas = () => {\r\n+            canvas.width = window.innerWidth\r\n+            canvas.height = window.innerHeight\r\n+        }\r\n \r\n-    resizeCanvas()\r\n-    window.addEventListener(\"resize\", resizeCanvas)\r\n+        resizeCanvas()\r\n+        window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-    // Colores minimalistas\r\n-    const colors = {\r\n-      primary: \"#e0f2fe\", // Azul claro\r\n-      secondary: \"#dcfce7\", // Verde menta\r\n-      accent: \"#fce7f3\", // Rosa pálido\r\n-      background: \"#f8fafc\", // Blanco grisáceo\r\n-    }\r\n+        // Colores minimalistas\r\n+        const colors = {\r\n+            primary: \"#e0f2fe\", // Azul claro\r\n+            secondary: \"#dcfce7\", // Verde menta\r\n+            accent: \"#fce7f3\", // Rosa pálido\r\n+            background: \"#f8fafc\", // Blanco grisáceo\r\n+        }\r\n \r\n-    // Crear círculos con diferentes colores y tamaños\r\n-    const circles: Circle[] = []\r\n-    const circleCount = 15\r\n+        // Crear círculos con diferentes colores y tamaños\r\n+        const circles: Circle[] = []\r\n+        const circleCount = 15\r\n \r\n-    for (let i = 0; i < circleCount; i++) {\r\n-      const radius = Math.random() * 150 + 50\r\n-      circles.push({\r\n-        x: Math.random() * canvas.width,\r\n-        y: Math.random() * canvas.height,\r\n-        radius,\r\n-        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n-        speedX: (Math.random() - 0.5) * 0.3,\r\n-        speedY: (Math.random() - 0.5) * 0.3,\r\n-        opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n-      })\r\n-    }\r\n+        for (let i = 0; i < circleCount; i++) {\r\n+            const radius = Math.random() * 150 + 50\r\n+            circles.push({\r\n+                x: Math.random() * canvas.width,\r\n+                y: Math.random() * canvas.height,\r\n+                radius,\r\n+                color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n+                speedX: (Math.random() - 0.5) * 0.3,\r\n+                speedY: (Math.random() - 0.5) * 0.3,\r\n+                opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n+            })\r\n+        }\r\n \r\n-    // Función de animación\r\n-    const animate = () => {\r\n-      ctx.fillStyle = colors.background\r\n-      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+        // Función de animación\r\n+        const animate = () => {\r\n+            ctx.fillStyle = colors.background\r\n+            ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n \r\n-      // Dibujar y mover círculos\r\n-      circles.forEach((circle) => {\r\n-        ctx.beginPath()\r\n-        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n-        ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n-          .toString(16)\r\n-          .padStart(2, \"0\")}`\r\n-        ctx.fill()\r\n+            // Dibujar y mover círculos\r\n+            circles.forEach((circle) => {\r\n+                ctx.beginPath()\r\n+                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n+                ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n+                    .toString(16)\r\n+                    .padStart(2, \"0\")}`\r\n+                ctx.fill()\r\n \r\n-        // Mover círculo\r\n-        circle.x += circle.speedX\r\n-        circle.y += circle.speedY\r\n+                // Mover círculo\r\n+                circle.x += circle.speedX\r\n+                circle.y += circle.speedY\r\n \r\n-        // Rebotar en los bordes\r\n-        if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n-          circle.speedX = -circle.speedX\r\n+                // Rebotar en los bordes\r\n+                if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n+                    circle.speedX = -circle.speedX\r\n+                }\r\n+                if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n+                    circle.speedY = -circle.speedY\r\n+                }\r\n+            })\r\n+\r\n+            requestAnimationFrame(animate)\r\n         }\r\n-        if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n-          circle.speedY = -circle.speedY\r\n-        }\r\n-      })\r\n \r\n-      requestAnimationFrame(animate)\r\n-    }\r\n+        animate()\r\n \r\n-    animate()\r\n+        return () => {\r\n+            window.removeEventListener(\"resize\", resizeCanvas)\r\n+        }\r\n+    }, [])\r\n \r\n-    return () => {\r\n-      window.removeEventListener(\"resize\", resizeCanvas)\r\n-    }\r\n-  }, [])\r\n-\r\n-  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n+    return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n }\r\n \r\n interface Circle {\r\n-  x: number\r\n-  y: number\r\n-  radius: number\r\n-  color: string\r\n-  speedX: number\r\n-  speedY: number\r\n-  opacity: number\r\n+    x: number\r\n+    y: number\r\n+    radius: number\r\n+    color: string\r\n+    speedX: number\r\n+    speedY: number\r\n+    opacity: number\r\n }\r\n"
                },
                {
                    "date": 1745196780455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,17 +20,17 @@\n \r\n         resizeCanvas()\r\n         window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-        // Colores minimalistas\r\n+        \r\n         const colors = {\r\n             primary: \"#e0f2fe\", // Azul claro\r\n             secondary: \"#dcfce7\", // Verde menta\r\n             accent: \"#fce7f3\", // Rosa pálido\r\n             background: \"#f8fafc\", // Blanco grisáceo\r\n         }\r\n \r\n-        // Crear círculos con diferentes colores y tamaños\r\n+        \r\n         const circles: Circle[] = []\r\n         const circleCount = 15\r\n \r\n         for (let i = 0; i < circleCount; i++) {\r\n"
                },
                {
                    "date": 1745197381680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,97 +1,253 @@\n \"use client\"\r\n \r\n-import { useEffect, useRef } from \"react\"\r\n+import { useEffect, useRef, useState } from \"react\"\r\n \r\n export default function AnimatedBackground() {\r\n-    const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n+  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })\r\n \r\n-    useEffect(() => {\r\n-        const canvas = canvasRef.current\r\n-        if (!canvas) return\r\n+  useEffect(() => {\r\n+    const canvas = canvasRef.current\r\n+    if (!canvas) return\r\n \r\n-        const ctx = canvas.getContext(\"2d\")\r\n-        if (!ctx) return\r\n+    const ctx = canvas.getContext(\"2d\")\r\n+    if (!ctx) return\r\n \r\n-       \r\n-        const resizeCanvas = () => {\r\n-            canvas.width = window.innerWidth\r\n-            canvas.height = window.innerHeight\r\n-        }\r\n+    // Configurar el canvas para que ocupe toda la pantalla\r\n+    const resizeCanvas = () => {\r\n+      canvas.width = window.innerWidth\r\n+      canvas.height = window.innerHeight\r\n+    }\r\n \r\n-        resizeCanvas()\r\n-        window.addEventListener(\"resize\", resizeCanvas)\r\n+    resizeCanvas()\r\n+    window.addEventListener(\"resize\", resizeCanvas)\r\n \r\n-        \r\n-        const colors = {\r\n-            primary: \"#e0f2fe\", // Azul claro\r\n-            secondary: \"#dcfce7\", // Verde menta\r\n-            accent: \"#fce7f3\", // Rosa pálido\r\n-            background: \"#f8fafc\", // Blanco grisáceo\r\n-        }\r\n+    // Seguimiento del cursor\r\n+    const handleMouseMove = (e: MouseEvent) => {\r\n+      setMousePosition({ x: e.clientX, y: e.clientY })\r\n+    }\r\n+    window.addEventListener(\"mousemove\", handleMouseMove)\r\n \r\n-        \r\n-        const circles: Circle[] = []\r\n-        const circleCount = 15\r\n+    // Colores minimalistas pero más vibrantes\r\n+    const colors = {\r\n+      primary: \"#38bdf8\", // Azul cielo más vibrante\r\n+      secondary: \"#4ade80\", // Verde menta más vibrante\r\n+      accent: \"#f472b6\", // Rosa más vibrante\r\n+      background: \"#f8fafc\", // Blanco grisáceo\r\n+    }\r\n \r\n-        for (let i = 0; i < circleCount; i++) {\r\n-            const radius = Math.random() * 150 + 50\r\n-            circles.push({\r\n-                x: Math.random() * canvas.width,\r\n-                y: Math.random() * canvas.height,\r\n-                radius,\r\n-                color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n-                speedX: (Math.random() - 0.5) * 0.3,\r\n-                speedY: (Math.random() - 0.5) * 0.3,\r\n-                opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n-            })\r\n-        }\r\n+    // Crear diferentes tipos de formas\r\n+    const shapes: Shape[] = []\r\n+    const shapeCount = 25 // Más formas para mayor dinamismo\r\n \r\n-        // Función de animación\r\n-        const animate = () => {\r\n-            ctx.fillStyle = colors.background\r\n-            ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+    // Crear círculos\r\n+    for (let i = 0; i < shapeCount * 0.6; i++) {\r\n+      const radius = Math.random() * 120 + 40\r\n+      shapes.push({\r\n+        type: \"circle\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: radius,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n+        speedX: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n+        speedY: (Math.random() - 0.5) * 1.2, // Velocidad aumentada\r\n+        opacity: Math.random() * 0.3 + 0.15, // Opacidad entre 0.15 y 0.45\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: radius,\r\n+        rotation: 0,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.01,\r\n+      })\r\n+    }\r\n \r\n-            // Dibujar y mover círculos\r\n-            circles.forEach((circle) => {\r\n-                ctx.beginPath()\r\n-                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n-                ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n-                    .toString(16)\r\n-                    .padStart(2, \"0\")}`\r\n-                ctx.fill()\r\n+    // Crear cuadrados\r\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n+      const size = Math.random() * 100 + 30\r\n+      shapes.push({\r\n+        type: \"square\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: size,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n+        speedX: (Math.random() - 0.5) * 1.0,\r\n+        speedY: (Math.random() - 0.5) * 1.0,\r\n+        opacity: Math.random() * 0.3 + 0.15,\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: size,\r\n+        rotation: Math.random() * Math.PI * 2,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.02,\r\n+      })\r\n+    }\r\n \r\n-                // Mover círculo\r\n-                circle.x += circle.speedX\r\n-                circle.y += circle.speedY\r\n+    // Crear triángulos\r\n+    for (let i = 0; i < shapeCount * 0.2; i++) {\r\n+      const size = Math.random() * 80 + 40\r\n+      shapes.push({\r\n+        type: \"triangle\",\r\n+        x: Math.random() * canvas.width,\r\n+        y: Math.random() * canvas.height,\r\n+        size: size,\r\n+        color: Object.values(colors)[Math.floor(Math.random() * 3)],\r\n+        speedX: (Math.random() - 0.5) * 0.8,\r\n+        speedY: (Math.random() - 0.5) * 0.8,\r\n+        opacity: Math.random() * 0.3 + 0.15,\r\n+        pulseSpeed: Math.random() * 0.02 + 0.01,\r\n+        pulseDirection: 1,\r\n+        originalSize: size,\r\n+        rotation: Math.random() * Math.PI * 2,\r\n+        rotationSpeed: (Math.random() - 0.5) * 0.015,\r\n+      })\r\n+    }\r\n \r\n-                // Rebotar en los bordes\r\n-                if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n-                    circle.speedX = -circle.speedX\r\n-                }\r\n-                if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n-                    circle.speedY = -circle.speedY\r\n-                }\r\n-            })\r\n+    // Función para dibujar un círculo\r\n+    const drawCircle = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.beginPath()\r\n+      ctx.arc(shape.x, shape.y, shape.size / 2, 0, Math.PI * 2)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n \r\n-            requestAnimationFrame(animate)\r\n+      // Añadir brillo/resplandor\r\n+      ctx.beginPath()\r\n+      ctx.arc(shape.x, shape.y, shape.size / 2 + 10, 0, Math.PI * 2)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 0.3 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n+    }\r\n+\r\n+    // Función para dibujar un cuadrado\r\n+    const drawSquare = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.save()\r\n+      ctx.translate(shape.x, shape.y)\r\n+      ctx.rotate(shape.rotation)\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fillRect(-shape.size / 2, -shape.size / 2, shape.size, shape.size)\r\n+\r\n+      // Añadir brillo/resplandor\r\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.5 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.lineWidth = 8\r\n+      ctx.strokeRect(-shape.size / 2 - 5, -shape.size / 2 - 5, shape.size + 10, shape.size + 10)\r\n+      ctx.restore()\r\n+    }\r\n+\r\n+    // Función para dibujar un triángulo\r\n+    const drawTriangle = (shape: Shape) => {\r\n+      if (!ctx) return\r\n+      ctx.save()\r\n+      ctx.translate(shape.x, shape.y)\r\n+      ctx.rotate(shape.rotation)\r\n+      ctx.beginPath()\r\n+      ctx.moveTo(0, -shape.size / 2)\r\n+      ctx.lineTo(shape.size / 2, shape.size / 2)\r\n+      ctx.lineTo(-shape.size / 2, shape.size / 2)\r\n+      ctx.closePath()\r\n+      ctx.fillStyle = `${shape.color}${Math.round(shape.opacity * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.fill()\r\n+\r\n+      // Añadir brillo/resplandor\r\n+      ctx.beginPath()\r\n+      ctx.moveTo(0, -shape.size / 2 - 10)\r\n+      ctx.lineTo(shape.size / 2 + 10, shape.size / 2 + 10)\r\n+      ctx.lineTo(-shape.size / 2 - 10, shape.size / 2 + 10)\r\n+      ctx.closePath()\r\n+      ctx.strokeStyle = `${shape.color}${Math.round(shape.opacity * 0.4 * 255)\r\n+        .toString(16)\r\n+        .padStart(2, \"0\")}`\r\n+      ctx.lineWidth = 5\r\n+      ctx.stroke()\r\n+      ctx.restore()\r\n+    }\r\n+\r\n+    // Función de animación\r\n+    const animate = () => {\r\n+      ctx.fillStyle = colors.background\r\n+      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n+\r\n+      // Dibujar y mover formas\r\n+      shapes.forEach((shape) => {\r\n+        // Dibujar forma según su tipo\r\n+        if (shape.type === \"circle\") {\r\n+          drawCircle(shape)\r\n+        } else if (shape.type === \"square\") {\r\n+          drawSquare(shape)\r\n+        } else if (shape.type === \"triangle\") {\r\n+          drawTriangle(shape)\r\n         }\r\n \r\n-        animate()\r\n+        // Efecto de pulsación (cambio de tamaño)\r\n+        shape.size += shape.pulseSpeed * shape.pulseDirection\r\n+        if (shape.size > shape.originalSize * 1.2 || shape.size < shape.originalSize * 0.8) {\r\n+          shape.pulseDirection *= -1\r\n+        }\r\n \r\n-        return () => {\r\n-            window.removeEventListener(\"resize\", resizeCanvas)\r\n+        // Rotación para cuadrados y triángulos\r\n+        if (shape.type !== \"circle\") {\r\n+          shape.rotation += shape.rotationSpeed\r\n         }\r\n-    }, [])\r\n \r\n-    return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n+        // Mover forma\r\n+        shape.x += shape.speedX\r\n+        shape.y += shape.speedY\r\n+\r\n+        // Interacción con el cursor\r\n+        const dx = mousePosition.x - shape.x\r\n+        const dy = mousePosition.y - shape.y\r\n+        const distance = Math.sqrt(dx * dx + dy * dy)\r\n+        const maxDistance = 200\r\n+\r\n+        if (distance < maxDistance) {\r\n+          const angle = Math.atan2(dy, dx)\r\n+          const force = (maxDistance - distance) / maxDistance\r\n+          shape.x -= Math.cos(angle) * force * 2\r\n+          shape.y -= Math.sin(angle) * force * 2\r\n+        }\r\n+\r\n+        // Rebotar en los bordes\r\n+        if (shape.x - shape.size / 2 < 0 || shape.x + shape.size / 2 > canvas.width) {\r\n+          shape.speedX = -shape.speedX\r\n+        }\r\n+        if (shape.y - shape.size / 2 < 0 || shape.y + shape.size / 2 > canvas.height) {\r\n+          shape.speedY = -shape.speedY\r\n+        }\r\n+      })\r\n+\r\n+      requestAnimationFrame(animate)\r\n+    }\r\n+\r\n+    animate()\r\n+\r\n+    return () => {\r\n+      window.removeEventListener(\"resize\", resizeCanvas)\r\n+      window.removeEventListener(\"mousemove\", handleMouseMove)\r\n+    }\r\n+  }, [])\r\n+\r\n+  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n }\r\n \r\n-interface Circle {\r\n-    x: number\r\n-    y: number\r\n-    radius: number\r\n-    color: string\r\n-    speedX: number\r\n-    speedY: number\r\n-    opacity: number\r\n+interface Shape {\r\n+  type: \"circle\" | \"square\" | \"triangle\"\r\n+  x: number\r\n+  y: number\r\n+  size: number\r\n+  color: string\r\n+  speedX: number\r\n+  speedY: number\r\n+  opacity: number\r\n+  pulseSpeed: number\r\n+  pulseDirection: number\r\n+  originalSize: number\r\n+  rotation: number\r\n+  rotationSpeed: number\r\n }\r\n"
                }
            ],
            "date": 1745196762391,
            "name": "Commit-0",
            "content": "\"use client\"\r\n\r\nimport { useEffect, useRef } from \"react\"\r\n\r\nexport default function AnimatedBackground() {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current\r\n    if (!canvas) return\r\n\r\n    const ctx = canvas.getContext(\"2d\")\r\n    if (!ctx) return\r\n\r\n    // Configurar el canvas para que ocupe toda la pantalla\r\n    const resizeCanvas = () => {\r\n      canvas.width = window.innerWidth\r\n      canvas.height = window.innerHeight\r\n    }\r\n\r\n    resizeCanvas()\r\n    window.addEventListener(\"resize\", resizeCanvas)\r\n\r\n    // Colores minimalistas\r\n    const colors = {\r\n      primary: \"#e0f2fe\", // Azul claro\r\n      secondary: \"#dcfce7\", // Verde menta\r\n      accent: \"#fce7f3\", // Rosa pálido\r\n      background: \"#f8fafc\", // Blanco grisáceo\r\n    }\r\n\r\n    // Crear círculos con diferentes colores y tamaños\r\n    const circles: Circle[] = []\r\n    const circleCount = 15\r\n\r\n    for (let i = 0; i < circleCount; i++) {\r\n      const radius = Math.random() * 150 + 50\r\n      circles.push({\r\n        x: Math.random() * canvas.width,\r\n        y: Math.random() * canvas.height,\r\n        radius,\r\n        color: Object.values(colors)[Math.floor(Math.random() * 3)], // Excluye el color de fondo\r\n        speedX: (Math.random() - 0.5) * 0.3,\r\n        speedY: (Math.random() - 0.5) * 0.3,\r\n        opacity: Math.random() * 0.2 + 0.1, // Opacidad entre 0.1 y 0.3\r\n      })\r\n    }\r\n\r\n    // Función de animación\r\n    const animate = () => {\r\n      ctx.fillStyle = colors.background\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n      // Dibujar y mover círculos\r\n      circles.forEach((circle) => {\r\n        ctx.beginPath()\r\n        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2)\r\n        ctx.fillStyle = `${circle.color}${Math.round(circle.opacity * 255)\r\n          .toString(16)\r\n          .padStart(2, \"0\")}`\r\n        ctx.fill()\r\n\r\n        // Mover círculo\r\n        circle.x += circle.speedX\r\n        circle.y += circle.speedY\r\n\r\n        // Rebotar en los bordes\r\n        if (circle.x - circle.radius < 0 || circle.x + circle.radius > canvas.width) {\r\n          circle.speedX = -circle.speedX\r\n        }\r\n        if (circle.y - circle.radius < 0 || circle.y + circle.radius > canvas.height) {\r\n          circle.speedY = -circle.speedY\r\n        }\r\n      })\r\n\r\n      requestAnimationFrame(animate)\r\n    }\r\n\r\n    animate()\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", resizeCanvas)\r\n    }\r\n  }, [])\r\n\r\n  return <canvas ref={canvasRef} className=\"fixed top-0 left-0 w-full h-full -z-10\" />\r\n}\r\n\r\ninterface Circle {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  color: string\r\n  speedX: number\r\n  speedY: number\r\n  opacity: number\r\n}\r\n"
        }
    ]
}